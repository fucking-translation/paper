# 大话CAP定理

[原文](http://ksat.me/a-plain-english-introduction-to-cap-theorem)

</br>

&#8195;&#8195;你会经常听到CAP定理，该定理在设计分布式系统时指定了某种上限。与我的其他大多数入门教程一样，让我们通过与实际情况比较来了解CAP定理。

## 1. “记忆公司” 你的新事业：

&#8195;&#8195;昨晚当你的妻子感谢你还记得她的生日并给她买了一个生日礼物时，一个绝妙的好主意击中了你。有些人很难记住一些事情，但是这却是你特别擅长的事情。所以为什么不去开展一项可以利用你的才能的事业呢？你越考虑就越喜欢这个主意。实际上，你甚至会拿出新闻报纸上的广告来解释你的想法。

```
记忆公司！- 即使从未想起，也永远不会遗忘！
你是否曾为经常忘记很多事情而烦恼？不用担心，只需要打个电话过来就可以帮助到你！
当你需要记住一些事情的时候，请拨打555-55-REMEM，并告诉我们
但你需要记起一些事物的时候，举个例子：打电话告诉我们你的老板的电话是多少，并忘记它。当你需要知道你老板的电话时，请拨打同样的电话（555-55—REMEM），然后我们会告诉你，你老板的电话是多少。
费用：1次请求只需1毛钱
```

&#8195;&#8195;所以，你的典型电话交谈将如下所示：
- 客户：你好，你可以存一下我的邻居的生日吗？
- 你：当然，他的生日是几号？
- 客户：1月2号
- 你：（在笔记本中的该客户的那一页写上该信息）已经存上了，随时可以打电话过来再次询问你邻居的生日！
- 客户：谢谢！
- 你：不客气！我们将收取你1毛钱的费用。

## 2. 你（的事业）扩大规模

&#8195;&#8195;你的事业被YCombinator投资。你的主题太过简单，除了笔记本和电话之外什么都不需要。但效果如此之好，以至于像野火一样蔓延开来。你开始每天都要接听上百个电话了。

&#8195;&#8195;这里就遇到一个问题，你发现越来越多的客户需要排队等待来与你沟通。他们中的大多数甚至都挂断了等待音。此外，如果你前一天生病且无法上班，你将失去一整天的业务。更别提那些当天就想要信息的所有不满意的客户。

&#8195;&#8195;你开始了一个简单的计划：
&#8195;&#8195;1. 你和你的妻子每人一部电话分机。
&#8195;&#8195;2. 客户仍然拨打555-55-REMEM，并且需要记住一个数字。
&#8195;&#8195;3. 电话交换机会将客户转接一个空闲且同样可以帮助到他的人那里。

## 3. 你有了第一次“糟糕的服务”

&#8195;&#8195;在你实现这个新系统的两天后，你收到一个老客户的电话，对话的过程是这样子的：

- 老李：你好
- 你：记忆公司，很高兴收到你的来电，我可以为你做点什么？
- 老李：你可以告诉我一下我飞北京的航班吗？
- 你：当然，请给我一首歌的时间
 （你快速地查看你的笔记本）
 （我擦嘞！在老李的那一页上，并没有找到他的航班信息）！！！！
- 你：亲，这里好像有个问题，你并没有告诉我们你飞北京的航班呢！
- 老李：纳尼！我昨天才给你们打的电话（挂断了电话）

&#8195;&#8195;为什么会发生这种情况？是老李在说谎吗？你想了一下然后菊花一紧！难道老李昨天是给你老婆打的电话？你来到老婆的桌子旁并翻看她的笔记本。确认了确实是这样。你告诉你的老婆然后她也意识到这个问题。

&#8195;&#8195;你的分布式设计中有多么可怕的缺陷！你的分布式系统不能保证一致性！这可能导致客户向你们其中一人更新的信息，但是下一次打电话却被转接到另一个人那里，导致记忆公司的回复是不一致的。

## 4. 修复一致性问题

&#8195;&#8195;好吧，你的竞争对手可能会忽略（自己造成的）糟糕的服务，但是你不会。当你的妻子睡觉时，你想了一晚上并在早晨的时候想到一个完美的计划，你摇醒你的妻子告诉她：

“亲爱的，这就是我们从现在开始要做的事情”

- 不管是谁接收到客户的请求（客户希望我们能记下一些事情），在结束通话之前我们要告诉对方。
- 这样我们俩都记下了所有的信息
- 当用户下一次需要查询他已存出的信息的时候，我们不需要和彼此沟通，因为我们的笔记本上都记录了最新更新的信息，我们直接查就好了。

&#8195;&#8195;尽管这里还有一个问题：就是这个更新的请求必须涉及彼此双方，在此期间我们不能并行的工作（举个例子：但你收到一个更新信息的请求后，并让我也更新相应的信息。此时，我不能收听其他的电话请求）。但是这依然没有问题，因为我们收到的大部分电话都是查询请求（客户更新一次信息，之后需要查询很多次）。除此之外，我们会不惜任何代价确保信息的准确性。

&#8195;&#8195;你的妻子回答，“但是这个系统依然有很多你没有考虑到的问题，如果我们其中一个在特殊的日子没有工作怎么办？在那一天我们不能接受任何更新的请求，因为另一个人不能更新该信息！我们将遇到可用性的问题，举个例子，如果我收到一个更新信息的请求，我将永远无法完成这次通话，因为即使我将需要更新的信息写进笔记本里，我却不会更新你的笔记本，所以导致我不能完成这次校准。“

## 5. 你想到了一个更好的解决方案

&#8195;&#8195;你首先意识到分布式系统并不像你想象的那样简单，想出一个同时保证“一致性和可用性”的解决方案是否困难？可能对于其他人来说很困难，但对于你来说不是！！第二天早上你又想到一个竞争对手不会想到的解决方案！你再一次摇醒你的妻子。

&#8195;&#8195;“看”，你对她说，“我们可以这样做来保证一致性和可用性，这个计划和我昨天告诉你的十分相似”。

- 1）我们在校准信息之前，不管何时，其中一个接收到更新请求（客户想让我们记下一些事情）的电话时，如果另一个人有空，则告诉另一个人更新信息。这种方式我们可以记下任何需要更新的信息。
- 2）但是如果另一个人没空（无法报告工作），我们向对方发送关于这次更新的邮件。
- 3）当第二天，对方开始工作的时候，他首先查看所有的邮件，更新他的笔记本，然后再开始接听第一次电话。

&#8195;&#8195;“真是个天才”，你的妻子说道，“我想不出这个系统中还有什么缺陷，我们就使用这种方式吧”。

&#8195;&#8195;记忆公司，开始可以同时保证一致性和可用性了。

## 6. 你的妻子愤怒了

&#8195;&#8195;开始的时候一切正常。你的系统是具有一致性的。你的系统在其中一人无法报告工作的时候依然运行的很好。但是如果你们两个人都能够报告工作并且其中一人无法更新另一人的信息该怎么办？还记得这些天你一直用你那狗屎一样的主意把你的妻子从睡梦中摇醒吗？如果你的妻子决定开始接听电话但是十分生气并决定不更新你一天内更新的内容。你的主意彻底破产。你的主意可以确保一致性和可用性，但是无法确保分区容错性。

&#8195;&#8195;你可以通过不接听任何电话直到你和妻子和好来保证分区容错性。但是这段时间你的系统又不能保证可用性了。。。

## 7. 结论

&#8195;&#8195;让我们来看一下CAP定理，他的内容是：`当你在设计分布式系统的时候，你无法保证同时实现一致性，可用性和分区容错性，你只能同时实现其中的两个特性`：

- 一致性：你的客户，一旦在你这里更新了信息，在之后打电话时，他们总是能获取到最新的信息，不管他们是过了多久打过来的。
- 可用性：记忆公司将一致保持打电话的可用性，直到你们其中之一（你或你的妻子）报告工作。
- 分区容错性：记忆公司将会一直运行即使你和你的妻子之间失去联系。

## 奖金：最终与业务员保持一致

这里有个值得深思的地方，你可以经常和业务员进行沟通，一旦你和你的妻子中某一个人的笔记被更新了之后，该业务员可以更新另一个人的笔记。这种方式的好处就是，他可以在后台工作，而不会阻塞你或你妻子的信息更新的过程，他会一直等待另一个更新。这就是其他一些非关系型数据库的工作原理：一个节点在本地更新自己的信息，后台进程慢慢的同步这些信息到其他节点上。唯一的问题就是在某些时候无法保证一致性。举个例子：客户可以先打给你的妻子（存储信息），并在业务员更新你的笔记本之前，再次打电话并被转接到你这，他就不能得到一致的回复。但是这也说明，如果类似的情况可以被限制住，这绝不是一个坏主意。举个例子：假定用户不会在5分钟之内就忘记了刚刚存储的信息。

&#8195;&#8195;这就是CAP定理，用大白话为你带来了最终一致性。