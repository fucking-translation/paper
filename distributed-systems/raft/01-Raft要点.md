# Raft要点

[原文](https://github.com/async-raft/async-raft/blob/master/raft-essentials.md)  

</br>

本文档介绍了Raft协议的基本细节，以帮助协议实现者。 因此，本文档假定至少对[Raft规范](https://raft.github.io/raft.pdf)有所了解，并包括对该规范相关部分的引用。

## 定义
- `server`: 运行着一个`Raft`协议的节点。
- `cluster`: 一组`server`一起工作以满足`Raft`规范的要求。
- `committed` (日志): 一旦领导者创建的日志条目已经复制到大多数节点上后就会被提交。
- `applied` (日志): 当一个日志条目已经被提交并且领导者已经将它应用于自己的状态机时，表示这个日志条目已被应用了。连续的`AppendEntries`RPC请求将会包含上一次应用的日志条目的索引，所有的跟随者将会根据这个索引将日志应用于它们的状态机中。
- `election timeout`: 一个随机的时间段。当接收到`AppendEntries`和`RequestVote`请求后，将被重置为一个新的随机值（除非请求被拒绝）。如果超过这个时间段，节点将会开始重新选举。
- `election timeout minimum`: 节点开始重新选举时需要等待的最小时间，为了合规，所有的节点都应该配置相同的最小值，`election timeout`应该总是比这个值要大。

## 基础
- 集群中，一个卓越的领导者被选出来后，将会被完全授权去管理日志的复制。§5.0
- 领导者接受客户端发来的日志条目，将这些日志条目复制到其他节点上，并告诉它们什么时候将这些日志条目应用于它们的状态机是安全的。§5.0
- 数据总是从领导者流向跟随者，不会有其他的流向。§5.0
- 当领导者下线了，一个新的领导者将会被选出来。§5.0
- 在任何时间每个节点都将处于四种状态之一：领导者（`leader`）(§5.0),候选者（`candidate`）(§5.0),跟随者（`follower`）(§5.0)，或者非投票者（`non-voter`）(§6).

## 任期
- 时间被划分为任意长度的任期. §5.1
- 每个节点存储一个当前的任期号，该任期号随着时间自增。5.1
- 每个任期将随着选举开始，选举中有一个或多个候选者尝试成为领导者。§5.1
- 如果某个候选者赢得了选举，将在该任期中剩下的时间担任领导者。§5.1
- 在某些情况下，选举可能会造成投票分割(即多个候选者获得同样的选票)，这时，任期将不会选举出领导者并结束。一个新的任期（伴随新的选举）将会快速的开始。`Raft`协议确保在给定的任期内只有一个领导者。§5.1

## 节点角色
- 当节点启动时，它们充当跟随者角色，并且只要收到领导者或者候选者合法的RPCs请求，将仍然充当跟随者角色。§5.2
- 如果节点接收到的请求携带的是更小的任期号，它将拒绝这个请求。§5.1
- 节点交流时，可以交换当前的任期号。如果一个节点的任期号小于另一个节点，它将更新自己的任期号到更大的那个值。§5.1
- 为了避免已被移除的节点开始新的选举而破坏集群，当集群中的节点认为领导者存在时，将忽略`RequestVote`RPC请求。尤其是，当节点在小于当前领导者的最小选举超时时间内收到`RequestVote`RPC请求，它将不会更新它的任期或者给这个投票请求授权。§6
- 当领导者或者获选人发现自己的任期比其他节点的要小，将立刻切换成跟随者状态。§5.1
- 投票者如果发现自己的日志比候选者要更新，一定要拒绝他的投票请求。如果日志的最后一个条目具有不同的任期，那么带有较大任期的日志将是最新的。如果多个日志以相同的任期号结束，则日志越长，该日志越新。§5.4.1

### 跟随者(`follower`)
跟随者节点简单的响应来自领导者和候选者的请求。§5.1

- 当接收到来自领导者或候选者的任意一个合理的RPC请求，跟随者将开启一个新的随机选举超时。§5.2
- 如果跟随者在选举超时窗口内，没有接收到任何的请求，它将假定集群中没有可用的领导者，它将切换到候选者的状态，并开始为了成为新的领导者而竞选。§5.2

### 非投票者(`non-voter`)
非投票者和跟随者一样，只是不参与选举。§6

### 候选者(候选者))
候选者通过发送`RequestVote`RPC请求以竞选成为集群的领导者。§5.1

- 第一步，候选者增加当前任期。§5.2
- 第二步，在配置的范围内开启新一轮的选举。§5.2
- 第三步，它将为自己投票并同时向集群中的其他节点发送`RequestVote`RPC请求。§5.2
- 一个候选者将一直持续这种状态直到以下三种情况之一发生：（1）它赢得了选举（2）另一个节点成为了领导者（3）在选举超时时间内没有选出领导者 §5.2

#### 赢得选举
- 在同一个任期内，如果某个候选者受到了集群中绝大多数的节点的投票，它将赢得选举。§5.2
- 每个节点基于`先来先得`的原则，在给定的任期内，最多只能给一个候选者投票。§5.2
- 一旦一个候选者赢得选举，它将成为领导者。§5.2

#### 落选
- 当候选者等待投票结果时，如果接收到另一个声称是领导者的节点发送的`AppendEntries`RPC请求时，将导致该节点落选。§5.2
- 如果领导者的任期号（包括在它的RPC请求中的任期号）至少和候选者当前任期号一样大，候选者将认为该领导者是合法的，并切换到跟随者模式。§5.2
- 如果RPC请求中的任期号小于候选者的当前任期号，候选者将拒绝这个RPC请求并保持候选的状态。§5.2

#### 选举僵局 (投票分裂)
- 如果候选者在收到足够的选票之前超时了，并且在其他领导者掌权之前，开始新一轮选举（增加任期号并开始新一轮`RequestVote`RPC）。

#### `RequestVote`RPC实现
1. 如果`RequestVote`RPC中的任期号小于投票者当前任期号($5.1)或者投票者在领导者的最小超市时间的窗口内接收到领导者的心跳($6)，则回复`false`。
2. 如果`voted_for`是`None`或者是候选者的id，并且候选者的日志至少和投票者的日志一样新，则投票给该候选者。(§5.2, §5.4)。

### 领导者(`leader`)
集群的领导者处理所有的客户端请求并且客户端如果接收到其他节点的请求一定要重定向到领导者。(§5.1)

- 在任期的开始，领导者提交一个空的没有任何操作的日志条目。§8
- 一定要周期性的向所有跟随者发送心跳（即空的`AppendEntries`RPC）以维护领导者的权威并阻止新一轮的选举。§5.2
- 必须服务客户端的请求。每个客户端请求都包含要由复制状态机执行的命令。领导者将这个命令追加到日志中作为一个新的条目，然后并行发布`AppendEntries`RPC请求到集群中的其他节点以复制该日志条目。§5.3
- 一旦该日志条目已被提交，则领导者将应用该条目到状态机上，并返回执行的结果给客户端。§5.3
- 如果跟随者奔溃或者运行缓慢，或者存在网络丢包情况，领导者将会一直重试`AppendEntries`RPC请求（即使他已经响应了客户端）直到所有的跟随者最终存储了所有的日志条目。(§5.3); 为了更好的性能，`AppendEntries`RPC请求应该并行发布。`AppendEntries`RPC是幂等的(idempotent)(§5.1).
- 领导者跟踪它知道的已被提交的最高索引，并将该索引包含在将来的`AppendEntries`RPC请求（包括心跳）中，以便其他节点最终找到。$5.3
- 一旦跟随者知道该日志条目已被提交，则将该条目按照日志的顺序应用于自己本地的状态机。§5.3
- 领导者永远不会覆盖或删除它自己的日志条目。§5.3

#### 复制
- 领导者在给定的任期中，根据给定的日志索引最多创建一个日志条目。并且日志条目在日志中的位置永远也不会改变。§5.3
- 当发送`AppendEntries`RPC时，领导者在紧随新条目之前的日志中包含索引和日志条目的任期。如果跟随者没有在它的日志中发现具有同样索引和任期的条目时，则拒绝领导者发送过来的新条目。§5.3
- 领导者通过强迫跟随者重复自己的日志来处理日志不一致的问题。这意味着跟随者日志中的冲突条目将被领导者中的日志条目覆盖（这只会在为提交的日志条目中发生）§5.3
- 为了让跟随者的日志和自己保持一致，领导者必须找到两者都匹配的最新的日志条目，删除跟随者中在那个点之后的日志条目，并向跟随者发送在那个点之后的领导者的日志条目。§5.3
- 所有的这些行为都发生在响应`AppendEntries`RPC请求的一致性检查。 领导者将会为每个跟随者维护一个`next_index`的值，这个值表示是领导者将要发送给对应跟随者的下一条日志条目的索引。§5.3
- 当领导者第一次掌权时，它将为集群中的所有节点初始化`next_index`值为它日志中最后一个日志的索引值加1。§5.3
- 如果跟随者和领导者的日志不一致，追加日志条目的一致性检查将会在下一次发送给跟随者的`AppendEntries`RPC中失败。在被拒绝之后，领导者将会将`next_index`值减1并重试`AppendEntries`RPC请求。最终`next_index`值将会到达某个值，使得领导者和跟随者的日志一致，此时，追加日志条目将会成功，并且跟随者会移除所有的冲突的日志条目，并追加领导者的日志条目，保持和领导者的一致性。并在任期余下的时间都保持这种方式。§5.3

#### 日志一致性检查优化
跟随者可以包含冲突条目的任期以及该任期下存储的第一条日志条目的索引。根据这些信息，领导者可以递减`next_index`以绕过该任期中的所有冲突的日志条目。每个具有冲突条目的任期都需要`AppendEntries`RPC，而不是每个条目一个RPC。§5.3

##### `AppendEntries`RPC实现
1. 如果`AppendEntries`RPC中携带的任期小于跟随者当前的任期，则返回`false`。§5.1.
2. 如果索引为`prev_log_index`的日志中不包含`prev_log_term`的任期时，返回`false`。(§5.3) 在需要的时候使用日志一致性检查。
3. 如果已存在的日志条目和新的日志条目发生冲突（相同的索引但是不同的任期），删除现有条目及其后的所有内容。§5.3
4. 追加日志中尚未存在的新条目。
5. 如果`leader_commit`大于`commit_index`，将`commit_index`设到最小值（`leader_commit`指上一个最新条目的索引）。

## 配置更改
为了确保安全性，配置变更必须使用两阶段算法，被称为`一致性共识`算法。§6

- 一旦节点添加了新的配置条目到它的日志上时，它未来的所有决定都将使用该配置（节点总是使用其日志中最新的配置，不管它的条目是否提交）§6
- 当集群进入一致性共识状态后，日志条目总是在相同的配置下复制到集群中的所有节点上。§6
- 来自任意配置的任意节点都可以充当领导者。§6
- 选举和提交条目的协议需要将大多数节点与新旧配置分开。§6
- 为了避免造成不可用, `Raft`在配置更改之前引入另一个阶段。该阶段中，新加入的节点全都作为非投票者（领导者复制日志条目给它们，但是它们不参与选举）。一旦一个旧节点追上了集群中其他节点，则按照上面描述的重新进行配置。§6
- 如果集群领导者不是新配置的一部分时，一旦新配置的日志条目被提交，则领导者下台（切换到跟随者的状态）这表明，领导者将有一段时间来管理一个不包含自己的集群（提交新配置时），它复制日志但是算他自己。提交新配置时会发生领导者的状态切换，因为这是新配置可以独立运行的第一步（始终可以从新配置中选择一个新的领导者）。在那一步之前，可能只有旧配置的节点可以被选择为领导者。§6

## 日志压缩 | 快照
在日志快照中，整个系统状态都将写入稳定存储中的快照中。那么到那时（快照存储的点）的整个日志将被抛弃。

- 每个节点独立的进行快照，快照的日志部分仅覆盖已提交的日志条目。§7
- 大多数的工作包括状态机将当前状态写入快照。§7
- 快照中包含一小部分元数据：包含的`last_included_index`是快照替换后的日志中最后一个条目的索引（状态机应用的最后一个条目），`last_included_term`也是该条目中的任期。§7
- 为了开启集群中成员关系变更的功能（§6）, 快照还包含截至`last_included_index`索引的日志中的最新配置。§7
- 一旦节点的快照写入完成，它将删除在`last_included_index`之前的所有日志条目，以及之前的任何快照。§7
- 快照中的`last_included_index`和`last_included_term`必须在日志中可以被识别以支持日志的一致性检查。这可能是一种特殊类型的日志条目，它指向快炸并保存快照的相关元数据，包括索引和任期。§7

### 领导者到跟随者的快照
尽管每个节点都独立的进行快照，领导者必须偶尔的发送快照到落后的跟随者中。

- 集群领导者使用`InstallSnapshot`RPC将快照发送给跟随者。§7
- 当领导者已经丢弃了需要发送给跟随者的下一条日志条目时，则会发生这种情况（基于它自身的压缩过程）. §7
- 和领导者步调一致的跟随者可能已经有了这个日志条目。然而，一些同步速度非常慢的跟随者和新加入集群的节点可能没有这个条目(§6)。领导者可以通过网络发送快照来保证此类跟随者保持最新的状态。§7
- 当某个跟随者从这个RPC接收到一个快照，它必须决定如何处理现有的日志条目，通常，快照将包含接收者日志中尚未包含的新信息。在这种情况下，跟随者将会丢弃它所有的日志。它的所有日志都被快照取代，并可能具有与快照冲突的为提交的日志条目。§7
- 如果相反，跟随者接收到描述其日志前缀的快照（由重传或错误导致），然后删除快照所包含的日志条目，但快照之后的日志条目依然有效且必须保留。§7

### `InstallSnapshot`RPC实现
1. 如果快照的任期小于自身当前任期则立即回复。
2. 如果是第一个块，则创建快照文件（偏移量是0）。
3. 以给定的偏移量将数据写入快照文件。
4. 如果`done`是`false`，则回复并等待更多的数块。
5. 保存快照文件，丢弃索引较小的任何现有或部分快照。
6. 如果现有日志条目的索引和任期与快照的最后一个包含的条目相同，请保留其后的日志条目并进行回复。
7. 丢弃全部日志.
8. 根据快照内容重置状态机（并加载快照的集群配置）。

## 客户端交互
`Raft`集群的客户端将它们的所有请求都发送给领导者。

- 当客户端第一次启动的时候，它随机连接`Raft`集群中的某个节点。§8
- 如果客户端第一次选择的不是领导者，该节点会拒绝客户端的请求并提供它接收到的领导者的信息。§8
- 如果领导者奔溃了，客户端请求将会超时，客户端将重试并随机选择另一个`Raft`节点。§8

### 请求转发
非领导者的节点将会转发客户端的请求到领导者上而不是拒绝请求。如果不知道领导者是谁，由于正在进行选举，该请求可能花一点时间来等待领导者被选出来。最坏的情况, 请求超时，客户端需要重新发送该请求。

### 线性一致性
#### 写入
我们对`Raft`的目标是实现线性一致性。如果领导者在提交日志条目之后但在响应客户端之前崩溃了，客户端可能会对新的领导者重试该命令，造成这个命令执行两遍。

解决办法是客户端为每一个命令分配一个唯一的序列号，然后，状态机跟踪为每个客户端处理的最新序列号以及相关的响应, 如果它接收到一个序列号已被执行的命令，它将立即响应而不是重新执行该命令。§8

请注意: 这是应用层的规范要求，并且必须在应用层面去实现。

#### 读取
线性一致性读取不允许返回陈旧的数据。

- 领导者在它新任期的开始提交一个空的没有操作的日志条目。§8
- 领导者在处理一个只读的请求前必须检查它是否已不是领导者。 `Raft`通过让领导者在响应只读请求之前与大多数节点交换心跳消息来解决此问题。§8

---

## 常见问题
### 可以按任期重置日志索引吗？
`Raft`协议明确的规定日志的索引只能单调增长，并没有提及每个任期可以重置日志索引。而且，每个任期都重置日志索引可能会造成其他问题。即领导者需要跟踪下一个任期和下一个将要复制到跟随者上的日志索引。

为了坚持统一，索引的单调增的方式，并且不会在每个任期内进行重置，是一种推荐的方式。

### 日志提交的定义是否包含领导者本身？
领导者包含在多数的统计中，除非领导者不在新配置的一部分的特定情况下的一致性共识。除非对于领导者不是新配置的一部分的特定情况达成了一致性共识。
